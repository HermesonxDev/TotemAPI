name: Laravel-React CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

jobs:
  check-and-build-docker:
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout do código
        uses: actions/checkout@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          
      - name: Verificar se a imagem já existe no DockerHub
        id: check_image
        run: |
          # Define a imagem
          DOCKER_IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/laravel-app:latest"
          
          # Tenta baixar a imagem para verificar se existe
          if docker pull $DOCKER_IMAGE &> /dev/null; then
            echo "A imagem já existe no DockerHub"
            echo "image_exists=true" >> $GITHUB_OUTPUT
          else
            echo "A imagem não existe no DockerHub"
            echo "image_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Build and Push Laravel Image
        if: steps.check_image.outputs.image_exists == 'false'
        uses: docker/build-push-action@v4
        with:
          context: ./
          file: ./Dockerfile-laravel
          push: true
          tags: ${{ secrets.DOCKERHUB_USERNAME }}/laravel-app:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: check-and-build-docker
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Production
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          port: ${{ secrets.SSH_PORT }}
          username: ${{ secrets.SSH_USERNAME }}
          password: ${{ secrets.SSH_PASSWORD }}
          script: |
            # Atualiza e instala dependências necessárias
            sudo apt-get update
            sudo apt-get install -y docker.io docker-compose

            # Define o diretório da aplicação
            APP_DIR="/var/www/html/totem"

            # Verifica se o repositório existe; se não, clona-o; se sim, atualiza-o
            if [ ! -d "$APP_DIR/.git" ]; then
              echo "Repositório não encontrado. Recriando..."
              sudo rm -rf $APP_DIR
              sudo mkdir -p $APP_DIR
              sudo chown -R $USER:$USER $APP_DIR
              cd $APP_DIR
              git clone https://${{ secrets.GIT_USERNAME }}:${{ secrets.GIT_TOKEN }}@github.com/${{ secrets.GIT_USERNAME }}/${{ secrets.GIT_REPO }}.git .
            else
              echo "Repositório encontrado. Atualizando..."
              cd $APP_DIR
              git fetch origin
              git reset --hard origin/main
            fi

            # Criar diretórios para SSL
            mkdir -p $APP_DIR/certbot/conf
            mkdir -p $APP_DIR/certbot/www
            mkdir -p $APP_DIR/nginx/conf.d

            # Atualizar arquivo .env
            cat > $APP_DIR/.env << 'EOL'
            APP_NAME=Laravel
            APP_ENV=local
            APP_KEY=base64:PO2G0sC8+pG2oUgpkw0kQFdCqNskbFwTBaZE6pfoXS8=
            APP_DEBUG=true
            APP_TIMEZONE=UTC
            APP_URL=https://dash.berp.app.br
            APP_LOCALE=pt
            APP_FALLBACK_LOCALE=en
            APP_FAKER_LOCALE=en_US
            APP_MAINTENANCE_DRIVER=file
            # APP_MAINTENANCE_STORE=database
            PHP_CLI_SERVER_WORKERS=4
            BCRYPT_ROUNDS=12
            LOG_CHANNEL=stack
            LOG_STACK=single
            LOG_DEPRECATIONS_CHANNEL=null
            LOG_LEVEL=debug
            DB_CONNECTION=mongodb
            DB_HOST=178.156.140.192
            DB_PORT=27017
            DB_DATABASE=klavi
            DB_USERNAME=berp
            DB_PASSWORD="@@Rqqo231i"
            DB_AUTHENTICATION_DATABASE=admin
            DB_DSN="mongodb://berp:@@Rqqo231i@178.156.140.192:27017/klavi?authSource=admin"
            DB_QUEUE_CONNECTION=sqlite_queue
            JWT_SECRET_KEY=67acc8b85@Berp669a0aa2.74101830Rqqo231i
            SESSION_DRIVER=file
            # SESSION_DRIVER=database
            SESSION_LIFETIME=120
            SESSION_ENCRYPT=false
            SESSION_PATH=/
            SESSION_DOMAIN=null
            BROADCAST_CONNECTION=log
            FILESYSTEM_DISK=local
            QUEUE_CONNECTION=database
            CACHE_STORE=file
            # CACHE_STORE=database
            CACHE_PREFIX=
            MEMCACHED_HOST=127.0.0.1
            REDIS_CLIENT=phpredis
            REDIS_HOST=127.0.0.1
            REDIS_PASSWORD=null
            REDIS_PORT=6379
            MAIL_MAILER=log
            MAIL_SCHEME=null
            MAIL_HOST=127.0.0.1
            MAIL_PORT=2525
            MAIL_USERNAME=null
            MAIL_PASSWORD=null
            MAIL_FROM_ADDRESS="hello@example.com"
            MAIL_FROM_NAME="${APP_NAME}"
            AWS_ACCESS_KEY_ID=AKIA3JA5YYWMMIKZZEI5
            AWS_SECRET_ACCESS_KEY=gw5L/psSmgAX9MDuCJ+CYPtLu98myIWXof3bZpCb
            AWS_DEFAULT_REGION=us-east-1
            AWS_BUCKET=berpimagenscloud
            AWS_URL=https://berpimagescloud.s3.sa-east-1.amazonaws.com
            AWS_ENDPOINT=https://s3.amazonaws.com
            AWS_USE_PATH_STYLE_ENDPOINT=false
            VITE_APP_NAME="${APP_NAME}"
            VITE_APP_NAME="${APP_NAME}"
            VITE_ASSET_URL=https://dash.berp.app.br
            ASSET_URL=https://dash.berp.app.br
            DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
            EOL

            # Add this to your GitHub Actions workflow file (main.yml)
            # This should be in the deploy job's script section

            # Criar arquivo de configuração do Nginx com suporte a SSL
            cat > $APP_DIR/nginx/conf.d/app.conf << 'EOL'
            server {
                listen 80;
                server_name dash.berp.app.br;
                
                # Redirecionar HTTP para HTTPS
                location / {
                    return 301 https://$host$request_uri;
                }
                
                # Permitir desafio do Certbot para renovação de certificados
                location /.well-known/acme-challenge/ {
                    root /var/www/certbot;
                }
            }

            server {
                listen 443 ssl;
                server_name dash.berp.app.br;
                
                # Certificados SSL
                ssl_certificate /etc/letsencrypt/live/dash.berp.app.br/fullchain.pem;
                ssl_certificate_key /etc/letsencrypt/live/dash.berp.app.br/privkey.pem;
                
                # Configurações de segurança SSL
                ssl_protocols TLSv1.2 TLSv1.3;
                ssl_prefer_server_ciphers on;
                ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
                ssl_session_timeout 1d;
                ssl_session_cache shared:SSL:10m;
                ssl_session_tickets off;
                
                # Adicionar HSTS
                add_header Strict-Transport-Security "max-age=63072000; includeSubDomains; preload" always;
                
                # Configurações de segurança
                add_header Referrer-Policy "strict-origin-when-cross-origin";
                add_header X-Content-Type-Options "nosniff" always;
                add_header X-XSS-Protection "1; mode=block" always;
                add_header X-Frame-Options "SAMEORIGIN" always;
                
                # Compressão Gzip
                gzip on;
                gzip_vary on;
                gzip_comp_level 6;
                gzip_types text/plain text/css application/json application/javascript text/xml;
                
                # Diretório raiz
                root /var/www/html/public;
                index index.php index.html;
                
                # Logs
                error_log /var/log/nginx/error.log;
                access_log /var/log/nginx/access.log;
                
                location / {
                    try_files $uri $uri/ /index.php?$query_string;
                    gzip_static on;
                }
                
                location ~ \.php$ {
                    try_files $uri =404;
                    fastcgi_split_path_info ^(.+\.php)(/.+)$;
                    # Use the service name with port
                    fastcgi_pass laravel_app:9000;
                    fastcgi_index index.php;
                    include fastcgi_params;
                    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
                    fastcgi_param PATH_INFO $fastcgi_path_info;
                    # Extended timeouts
                    fastcgi_connect_timeout 60;
                    fastcgi_send_timeout 60;
                    fastcgi_read_timeout 60;
                    fastcgi_buffer_size 16k;
                    fastcgi_buffers 4 16k;
                }
                
                # Permite carregamento de assets
                location ~* \.(jpg|jpeg|png|gif|ico|css|js|woff2|ttf|svg)$ {
                    expires 30d;
                    access_log off;
                    add_header Cache-Control "public, max-age=2592000";
                    try_files $uri $uri/ /index.php?$query_string;
                }
                
                # Negar acesso a arquivos sensíveis
                location ~ /\.(?!well-known).* {
                    deny all;
                }
            }
            EOL

            # Reiniciar serviços Docker
            cd $APP_DIR
            docker-compose down || true
            docker-compose up -d